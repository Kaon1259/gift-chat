<%- include('layouts/layout', { title: (typeof title !== 'undefined' ? title : 'GIF 채팅방') }) %>

<h1>GIF 채팅방</h1>
<fieldset>
  <legend>채팅방 목록</legend>
  <table>
    <thead>
      <tr>
        <th>방 제목</th>
        <th>종류</th>
        <th>허용 인원</th>
        <th>방장</th>
        <th>액션</th>
      </tr>
    </thead>
    <tbody>
    <% if (Array.isArray(rooms) && rooms.length) { %>
      <% rooms.forEach(function(room) { %>
        <tr data-id="<%= room._id %>">
          <td><%= room.title %></td>
          <td><%= room.password ? '비밀방' : '공개방' %></td>
          <td><%= room.max %></td>
          <!-- 방장 색상은 별도 필드가 있을 때만 적용 -->
          <td
            <% if (room.ownerColor) { %> style="color:<%= room.ownerColor %>" <% } %>
          ><%= room.owner %></td>
          <td>
            <button
              data-password="<%= room.password ? 'true' : 'false' %>"
              data-id="<%= room._id %>"
              class="join-btn"
            >입장</button>
          </td>
        </tr>
      <% }) %>
    <% } else { %>
      <tr><td colspan="5" style="text-align:center">등록된 채팅방이 없습니다.</td></tr>
    <% } %>
    </tbody>
  </table>

  <% if (typeof error !== 'undefined' && error) { %>
    <div class="error-message"><%= error %></div>
  <% } %>

  <a href="/room">채팅방 생성</a>
</fieldset>

<script src="/socket.io/socket.io.js"></script>
<script>
  // 같은 오리진이라면 호스트/포트 하드코딩 없이 네임스페이스만 지정
  const socket = io('/room', { path: '/socket.io' });

  //새로운 방이 생성되었으면 생성알림을 io('/room', { path: '/socket.io' });를 오픈한 모든 클라이언트에게 'newRoom' 이벤트를 송신하고 
  //아래는 수신후 tabel/tr을 추가한다.
  socket.on('newRoom', function (data) {
    const tr = document.createElement('tr');
    tr.dataset.id = data._id;

    let td = document.createElement('td');
    td.textContent = data.title;
    tr.appendChild(td);

    td = document.createElement('td');
    td.textContent = data.password ? '비밀방' : '공개방';
    tr.appendChild(td);

    td = document.createElement('td');
    td.textContent = data.max;
    tr.appendChild(td);

    td = document.createElement('td');
    if (data.ownerColor) td.style.color = data.ownerColor;
    td.textContent = data.owner;
    tr.appendChild(td);

    td = document.createElement('td');
    const button = document.createElement('button');
    button.textContent = '입장';
    button.className = 'join-btn';
    button.dataset.password = data.password ? 'true' : 'false';
    button.dataset.id = data._id;
    td.appendChild(button);
    tr.appendChild(td);

    document.querySelector('table tbody').appendChild(tr);
  });

  socket.on('removeRoom', function (id) {
    document.querySelectorAll('tbody tr').forEach(function (tr) {
      if (tr.dataset.id === id) tr.remove();
    });
  });

  // 이벤트 위임: 동적으로 추가된 버튼도 자동 처리
  document.querySelector('table tbody').addEventListener('click', function (e) {
    const btn = e.target.closest('.join-btn');
    if (!btn) return;

    if (btn.dataset.password === 'true') {
      const password = prompt('비밀번호를 입력하세요');
      // 공백/특수문자 대비
      location.href = '/room/' + btn.dataset.id + '?password=' + encodeURIComponent(password || '');
    } else {
      location.href = '/room/' + btn.dataset.id;
    }
  });

  // 초기 렌더된 버튼들에 대한 별도 바인딩 불필요 (위임으로 처리)
</script>

<script>
  window.onload = () => {
    const params = new URL(location.href).searchParams;
    const msg = params.get('error');
    if (msg) alert(msg);
  };
</script>
